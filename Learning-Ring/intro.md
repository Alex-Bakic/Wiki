<h1>The Ring Library</h1>
<br>

Ring is a library that allows us to work with HTTP requests and responses, by having them in the form of native Clojure hashmaps. When an HTTP request is issued to our webserver, Ring converts that request into a workable hashmap which we can manipulate.We can then issue a response in the same hashmap style. All we need to worry about when issuing our response is that it sticks to the [Ring specificiation](https://github.com/ring-clojure/ring/blob/master/SPEC), 
which highlights the different supported headers and keywords we can use when we respond to someone, all of which we will uncover further in this guide.

Ring has three specs which it exposes (visible for us to import into our own projects) and they are:

- **Request**, for issuing HTTP requests
- **Responses**, for issuing HTTP responses
- **Handlers**, which is the glue (the function) which Ring will call ,expecting us to take the HTTP request map which will we work with to generate an out going response, in the form of a hashmap.

I think the first two are relatively straightforward, they are just the hashmaps themselves that are generated by Ring which act as the equivalent HTTP message . When a client issued their request, just before we process it, Ring converts it into:

###### Example request to http://localhost:3000 , courtesy of the [Echo project](http://blog.bradlucas.com/posts/2018-05-18-learning-ring-and-building-echo/)* ######


  ```Clojure 
  {
    :ssl-client-cert nil,
    :protocol "HTTP/1.1",
    :remote-addr "0:0:0:0:0:0:0:1",
    :headers {
              "cache-control" "max-age=0",
              "accept"
              "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8",
              "upgrade-insecure-requests" "1",
              "connection" "keep-alive",
              "user-agent" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.181 Safari/537.36",
              "host" "localhost:3000",
              "accept-encoding" "gzip, deflate, br",
              "accept-language" "en-US,en;q=0.9"
              },
   :server-port 3000,
   :content-length nil,
   :content-type nil,
   :character-encoding nil,
   :uri "/",
   :server-name "localhost",
   :query-string nil,
   :body "",
   :scheme :http,
   :request-method :get

  }
  ```
 
This is what a handler for the path "http://localhost:3000/" could expect to have fed to it, and an example HTTP response could something like the below, which Ring would convert back into the format of the webserver in use. 

###### courtesy of the [Ring wiki](https://github.com/ring-clojure/ring/wiki/Concepts) ######
 
  ```Clojure
  {:status 200
   :headers {"Content-Type" "text/plain"}
   :body (:remote-addr request)}
  ```

Ring uses a concept called adapters which are the middleware between the webserver and the clojure code we define. The middleware keeps the same spec across Jetty, Netty , Mongrel and Apache webservers meaning we can use the `:status` , `:headers` keywords anyone there is an adapter for them.

This code shows that we expect the request of the client to be valid and we send the 200 status code. The :headers keyword takes a map of options, all in the spec, which we can specify. So for the "Content-Type" field we can specify that the content is just plain text. In the body, which is the core of the response all we are putting in there is the IP address of the client. 

But you're probably thinking *"Where did the request come from and how can we work with it?"*, well when the client made a request to us, Ring turned it into an equivalent Clojure hashmap before it **reached our handler**. The handler is the function which takes a HTTP request map, and returns an HTTP response map. It is the handler which is called by ring to gather what the client wants and how we can provide some sort of response. 

To show this, here is the full code snippet from the [ring wiki](https://github.com/ring-clojure/ring/wiki/Concepts) highlighting the very simple handler function.

  ```Clojure
  (defn what-is-my-ip [request]
  ;; the map that Ring gives you which contains the HTTP request data
  {:status 200
   :headers {"Content-Type" "text/plain"}
   :body (:remote-addr request)})
  
  ;; returning HTTP response
   ```

The :remote-addr keyword is a key in that map, which is linked to an IP address, namely the one of the client. 

Now if would like to use this handler, on our Jetty Web Server we could include the following to this code

  ```Clojure
   (refer 'ring.adapter.jetty :only '[run-jetty])
   
   (defn what-is-my-ip [request]
    ;; the map that Ring gives you which contains the HTTP request data
    {:status 200
     :headers {"Content-Type" "text/plain"}
     :body (:remote-addr request)})
   
   (run-jetty handler {:port 3000})
  ```

Handlers themselves are pretty boring. All they are is a map that Ring gets to translate into a HTTP response, what if we want to verify the data in a client's request, have different types of responses based on what data the client has supplied or format the data a certain way for the handler. My friend, I introduce you to **middleware**. 

Middleware extends the functionality of handlers by returning functions not data. Middleware functions need to take the original handler as it's first argument, followed by whatever data you want to be added or other functions to operate on the handler data etc. What the middleware function returns is a function ,our new handler function, which takes a request map and we will call the old handler with that map so that our middleware gets the hashmap of data we want to manipulate. We then wrap it however we would like and then send it off to Ring.

Let's say we are in the middle of making a Medium clone and we want to have the functionality to track how many articles a user has viewed. We decide that after they have viewed 5 articles for free they can view no more! If we were to just use a handler for this, we could write :



Essentially, these are the differences between handler and middleware. 

Handler :  Ring has HTTP response data --> Converts into map --> Invokes handler with the supplied data -->
           Issues response map response
           
Middleware : Ring has HTTP response data --> Converts into map --> Invokes our app variable with supplied data --> 
             App variable calls the middleware function supplying handler and data --> 
             Middleware function invokes handler with supplied data --> Issues map response
             
             
-- to do , show example middleware functions and process

Alright I think it is about time I walked through how this works. Let's say we are making a [Medium](https://www.medium.com) clone, and we want to , at a very rudimentary level, implement a counter for how many articles a client has viewed.

The issue with a handler sticking to the Ring specification would be it forces us to make use of global state as we can only take the one argument being the request map. 
  
  ```Clojure
  (defn handler
    [request]
    
    ;; to do , show issues and refactor with use of middleware.
    
    {:status 200
     :headers {"Content-Type" "text/plain"}                   
     :body (str "You have viewed " @view-count " articles this month. " )})
  ```
  
Without middleware we wouldn't be able to add higher-order-functionality or local state into our response maps. 
