# <p align="center">The Ring Library</p>

Ring is a library that allows us to work with HTTP requests and responses, by having them in the form of native Clojure hashmaps.
When an HTTP request is issued to us, Ring converts that request into a workable hashmap which we can manipulate and respond to. 
All we need to worry about when issuing our response is that it sticks to the [Ring specificiation](https://github.com/ring-clojure/ring/blob/master/SPEC), 
meaning the different supported headers and keywords we can use when we respond to someone, all of which we will uncover further in
this guide.

Ring has three specs which it exposes (visible for us to import into our own projects) and they are:

- **Request**, for issuing HTTP requests
- **Responses**, for issuing HTTP responses
- **Handlers**, which is the glue (the function) which allows us to work with the incoming response and the outgoing reply. 

I think the first two are relatively straightforward, they are just the hashmaps themselves that are generated by Ring which act as
the equivalent HTTP message . When a client issued their request, just before we process it, Ring converts it into:

Example request to http://localhost:3000 , courtesy of the [Echo project](http://blog.bradlucas.com/posts/2018-05-18-learning-ring-and-building-echo/)


  ```Clojure 
  {
    :ssl-client-cert nil,
    :protocol "HTTP/1.1",
    :remote-addr "0:0:0:0:0:0:0:1",
    :headers {
              "cache-control" "max-age=0",
              "accept"
              "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8",
              "upgrade-insecure-requests" "1",
              "connection" "keep-alive",
              "user-agent" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.181 Safari/537.36",
              "host" "localhost:3000",
              "accept-encoding" "gzip, deflate, br",
              "accept-language" "en-US,en;q=0.9"
              },
   :server-port 3000,
   :content-length nil,
   :content-type nil,
   :character-encoding nil,
   :uri "/",
   :server-name "localhost",
   :query-string nil,
   :body "",
   :scheme :http,
   :request-method :get

  }
  ```
 
 And an example HTTP response could be , courtesy of the [Ring wiki](https://github.com/ring-clojure/ring/wiki/Concepts)
 
  ```Clojure
  {:status 200
   :headers {"Content-Type" "text/plain"}
   :body (:remote-addr request)}
  ```

So  this code shows that we expect the request of the client to be valid and we send the 200 status code. The :headers keyword takes
a map of options, all in the spec, which we can specify. So for the "Content-Type" field we can specify that the content is just
plain text. In the body, which is the core of the response all we are putting in there is the IP address of the client. 

But you're probably thinking *"Where did request come from and how can we work with it?"*, well when the client made a request to us, Ring 
turned it into an equivalent Clojure hashmap before it **reached our handler**. 

-- to do  , define the handler.

The :remote-addr keyword is a key in that map, which is linked 
to an IP address, namely the one of the client. We are able to grab this request by the job of the handler, who is the 
