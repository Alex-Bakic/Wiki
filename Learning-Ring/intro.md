# <p align="center">The Ring Library</p>

Ring is a library that allows us to work with HTTP requests and responses, by having them in the form of native Clojure hashmaps.
When an HTTP request is issued to us, Ring converts that request into a workable hashmap which we can manipulate and respond to. 
All we need to worry about when issuing our response is that it sticks to the [Ring specificiation](https://github.com/ring-clojure/ring/blob/master/SPEC), 
highlighting the different supported headers and keywords we can use when we respond to someone, all of which we will uncover further in this guide.

Ring has three specs which it exposes (visible for us to import into our own projects) and they are:

- **Request**, for issuing HTTP requests
- **Responses**, for issuing HTTP responses
- **Handlers**, which is the glue (the function) which allows us to work with the incoming response and the outgoing reply. 

I think the first two are relatively straightforward, they are just the hashmaps themselves that are generated by Ring which act as the equivalent HTTP message . When a client issued their request, just before we process it, Ring converts it into:

Example request to http://localhost:3000 , courtesy of the [Echo project](http://blog.bradlucas.com/posts/2018-05-18-learning-ring-and-building-echo/)


  ```Clojure 
  {
    :ssl-client-cert nil,
    :protocol "HTTP/1.1",
    :remote-addr "0:0:0:0:0:0:0:1",
    :headers {
              "cache-control" "max-age=0",
              "accept"
              "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8",
              "upgrade-insecure-requests" "1",
              "connection" "keep-alive",
              "user-agent" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.181 Safari/537.36",
              "host" "localhost:3000",
              "accept-encoding" "gzip, deflate, br",
              "accept-language" "en-US,en;q=0.9"
              },
   :server-port 3000,
   :content-length nil,
   :content-type nil,
   :character-encoding nil,
   :uri "/",
   :server-name "localhost",
   :query-string nil,
   :body "",
   :scheme :http,
   :request-method :get

  }
  ```
 
 And an example HTTP response could be , courtesy of the [Ring wiki](https://github.com/ring-clojure/ring/wiki/Concepts)
 
  ```Clojure
  {:status 200
   :headers {"Content-Type" "text/plain"}
   :body (:remote-addr request)}
  ```

So  this code shows that we expect the request of the client to be valid and we send the 200 status code. The :headers keyword takes a map of options, all in the spec, which we can specify. So for the "Content-Type" field we can specify that the content is just plain text. In the body, which is the core of the response all we are putting in there is the IP address of the client. 

But you're probably thinking *"Where did request come from and how can we work with it?"*, well when the client made a request to us, Ring turned it into an equivalent Clojure hashmap before it **reached our handler**. The handler is the function which takes a HTTP request map, and returns an HTTP response map. It is the handler which is called by ring to gather what the client wants and how we can provide some sort of response. 

To show this, here is the full code snippet from the [ring wiki](https://github.com/ring-clojure/ring/wiki/Concepts) highlighting the very simple handler function.

  ```Clojure
  (defn what-is-my-ip [request]
  ;; the map that Ring gives you which contains the HTTP request data
  {:status 200
   :headers {"Content-Type" "text/plain"}
   :body (:remote-addr request)})
  
  ;; returning HTTP response
   ```

The :remote-addr keyword is a key in that map, which is linked to an IP address, namely the one of the client. 

Handlers themselves are pretty boring. All there are is a map that Ring gets to translate into a HTTP response, what if we want to verify the data in a client's request, or have different types of responses based on what data the client has supplied. My friend, I introduce you to **middleware**. 

Middleware extends the functionality of handlers by returning functions not data. Middleware functions need to take the original handler as it's first argument, followed by whatever data you want to be added or other functions to operate on the handler data etc. What the middleware function returns is our a function ,our new handler function,  which will call the old handler so that our middleware gets the hashmap of data we want to manipulate. Remember that Ring supplies handlers with the request to help them generate a response.  

In this example project [shown here](https://gist.github.com/weavejester/598020), we can see that some middleware was used and the app variable, calls the middleware function, wrap-params, and gives it the handler function. This variable returns a handler for Ring to use, and when web server is launched by 

  ```Clojure
  (run-jetty app {:port 8080})
  ```
 
 app is the handler which allows the web server to serve requests. 

Essentially, these are the differences between handler and middleware. 

Handler :  Ring has HTTP response data --> Converts into map --> Invokes handler with the supplied data -->
           Issues response map response
           
Middleware : Ring has HTTP response data --> Converts into map --> Invokes our app variable with supplied data --> 
             App variable calls the middleware function supplying handler and data --> 
             Middleware function invokes handler with supplied data --> Issues map response
             
             
-- to do , show example middleware functions and process
