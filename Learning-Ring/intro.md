<h1>The Ring Library</h1>
<br>

Ring is a library that allows us to work with HTTP requests and responses, by having them in the form of native Clojure hashmaps. When an HTTP request is issued to our webserver, Ring converts that request into a workable hashmap which we can manipulate.We can then issue a response in the same hashmap style. All we need to worry about when issuing our response is that it sticks to the [Ring specificiation](https://github.com/ring-clojure/ring/blob/master/SPEC), 
which highlights the different supported headers and keywords we can use when we respond to someone, all of which we will uncover further in this guide.

Ring has three specs which it exposes (visible for us to import into our own projects) and they are:

- **Request**, for issuing HTTP requests
- **Responses**, for issuing HTTP responses
- **Handlers**, which is the glue (the function) which Ring will call ,expecting us to take the HTTP request map which will we work with to generate an out going response, in the form of a hashmap.

I think the first two are relatively straightforward, they are just the hashmaps themselves that are generated by Ring which act as the equivalent HTTP message . When a client issued their request, just before we process it, Ring converts it into:

###### Example request to http://localhost:3000 , courtesy of the [Echo project](http://blog.bradlucas.com/posts/2018-05-18-learning-ring-and-building-echo/) ######


  ```Clojure 
  {
    :ssl-client-cert nil,
    :protocol "HTTP/1.1",
    :remote-addr "0:0:0:0:0:0:0:1",
    :headers {
              "cache-control" "max-age=0",
              "accept"
              "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8",
              "upgrade-insecure-requests" "1",
              "connection" "keep-alive",
              "user-agent" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.181 Safari/537.36",
              "host" "localhost:3000",
              "accept-encoding" "gzip, deflate, br",
              "accept-language" "en-US,en;q=0.9"
              },
   :server-port 3000,
   :content-length nil,
   :content-type nil,
   :character-encoding nil,
   :uri "/",
   :server-name "localhost",
   :query-string nil,
   :body "",
   :scheme :http,
   :request-method :get

  }
  ```
 
This is what a handler for the path "http://localhost:3000/" could expect to have fed to it, and an example HTTP response could be something like the below, which Ring would convert back into the format of the webserver in use. 

###### courtesy of the [Ring wiki](https://github.com/ring-clojure/ring/wiki/Concepts) ######
 
  ```Clojure
  {:status 200
   :headers {"Content-Type" "text/plain"}
   :body (:remote-addr request)}
  ```

Ring uses a concept called adapters which can be thought of as the middleware between the webserver, the default being Jetty,  and the clojure code we define. The adapters allow us to keep the same spec across Jetty, Netty , Mongrel and Apache webservers meaning we can use the `:status` , `:headers` keywords anyone there is an adapter for them.

This code shows that we expect the request of the client to be valid and we send the 200 status code. The `:headers` keyword takes a map of options, all in the spec, which we can specify. So for the "Content-Type" field we can specify that the content is just plain text. In the body, which is the core of the response all we are putting in there is the IP address of the client. 

But you're probably thinking *"Where did the request come from and how can we work with it?"*, well when the client made a request to us, Ring turned it into an equivalent Clojure hashmap before it reached our handler. The handler is the function which takes a HTTP request map, and returns an HTTP response map. It is the handler which is called by ring to gather what the client wants and how we can provide some sort of response. 

To show this, here is the full code snippet from the [ring wiki](https://github.com/ring-clojure/ring/wiki/Concepts) highlighting the very simple handler function.

  ```Clojure
  (defn what-is-my-ip [request]
  ;; the map that Ring gives you which contains the HTTP request data
  {:status 200
   :headers {"Content-Type" "text/plain"}
   :body (:remote-addr request)})
  
  ;; returning HTTP response
   ```

The :remote-addr keyword is a key in that map, which is linked to an IP address, namely the one of the client. 

Now if would like to use this handler, on our Jetty Web Server we could include the following to this code

  ```Clojure
   (refer 'ring.adapter.jetty :only '[run-jetty])
   
   (defn what-is-my-ip [request]
    ;; the map that Ring gives you which contains the HTTP request data
    {:status 200
     :headers {"Content-Type" "text/plain"}
     :body (:remote-addr request)})
   
   (run-jetty handler {:port 3000})
    ;; now the server is up , if you make a GET request to localhost:3000 you will get back your IP address
    ;; in the response body.
  ```

Handlers themselves are pretty boring. All they are is a map that Ring gets to translate into a HTTP response, what if we want to verify the data in a client's request, have different types of responses based on what data the client has supplied or format the data a certain way for the handler. My friend, I introduce you to **middleware**. 

Middleware extends the functionality of handlers by returning functions not data. Middleware functions need to take the original handler as it's first argument, followed by whatever data you want to be added or other functions to operate on the handler data etc. What the middleware function returns is a function ,our new handler function, which takes a request map and we will call the old handler with that map so that our middleware gets the hashmap of data we want to manipulate. We then operate on the data however we would like and then send it off to Ring.

To look at a real world example, let's imagine we have a website.Now , a user has just completed one of our forms to become a member, and the form data is passed to us in their HTTP request, more specifically in the body is all of the customers json data.  Now this is a bit tricky as while the response map itself is a clojure hashmap the actual data mapped to the ```:body``` keyword is left as unconverted json. What we can do is use the json middleware that is provided to us by the [ring-json](https://github.com/ring-clojure/ring-json) library to convert json into clojure data structures. 

If we look in the library and see the ```wrap-json-body``` function it says :

  ```
  "Middleware that parses the body of JSON request maps, and replaces the :body
  key with the parsed data structure. Requests without a JSON content type are
  unaffected.
  
   Accepts the following options:
  :keywords?          - true if the keys of maps should be turned into keywords
  :bigdecimals?       - true if BigDecimals should be used instead of Doubles
  :malformed-response - a response map to return when the JSON is malformed"
  ```
  
The library also shows the idiomatic way of doing this:

  ```Clojure
  (use '[ring.middleware.json :only [wrap-json-body]]
       '[ring.util.response :only [response]])

  (defn handler [request]
    (prn (get-in request [:body "user"]))
    (response "Uploaded user."))
    ;; response just Ring response with the given body, status of 200, and no headers.

  (def app
    (wrap-json-body handler {:keywords? true :bigdecimals? true}))
    
  ;; (run-jetty app {:port 3000}) would call app and be given the handler function inside. 
  ```

So , our handler is given the request map, which itself has been converted in Clojure, but the ```:body``` is still json. We extract that data out with ```get-in```

I think it is best to start from the app and then see what is happening in the middleware, as the app is what is called by jetty and is ran first. In our ```app``` variable, the wrapper is called and we pass our desired handler to it, and we would like use clojure keywrods as the json map keys. As we know with all middleware, their common pattern is to return a function, which accepts the request map. When our web server calls app , it will pass the request map to it. Let's see what happens inside that function :

###### ring-json/json.clj --> wrap-json-body ######

  ```Clojure
    (fn
    ([request]
     (if-let [request (json-body-request request options)]
       (handler request)
       malformed-response))
  ```
So , the ```json-body-request``` function is called which converts the data. Now if the json is not malformed (corrupt) then the operation will go through and we will return call the original handler with the clojure hashmap. Don't worry about the ```prn``` , as that is just how this handler has chosen to output the data. If the json is malformed, then we return the malformed-response map.

Thanks to the ```wrap-json-body``` handler , this functionality can be used in any new handler we define, and the handler doesn't need to be aware of the different formats. It's only concern is working with the clojure data. Moreover, we don't have to repeat this logic over and over, as it would be likely to come up again in other interactive parts of a website where data is being submitted from the user.

## Conclusion

Essentially, these are the differences between handler and middleware.

Handler : 

  ```
  Ring has HTTP response data --> 
  Converts into map --> 
  Invokes handler with the supplied data --> 
  Issues response map response
  ```
Middleware : 

  ```
  Ring has HTTP response data --> 
  Converts into map --> 
  Invokes our app variable with supplied data --> 
  App variable calls the middleware function supplying handler and data --> 
  Middleware function invokes handler with supplied data -->
  Issues map response
  ```    
The reason we use middleware is to separate the concerns with handlers and let them focus on servicing the requests and responses as simply as possible. Middleware contains logic that would otherwise be repeated all over the program, moreover as they ultimately return a response map after the inner function call, they can be composed and allow functionality to be layered, the result being simpler programs. What should stay in a handler and what should be extracted out into middleware can be tricky at times , but the general rule of thumb is to have unique, custom-made logic stay in the appropriate handler, and general-use functionality in middleware. 
